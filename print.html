<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yarrow GUI Framework</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="getting_started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">1.</strong> Quick Start Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quick_start/setting_up.html"><strong aria-hidden="true">1.1.</strong> Setting Up</a></li><li class="chapter-item expanded "><a href="quick_start/your_first_element.html"><strong aria-hidden="true">1.2.</strong> Your First Element</a></li><li class="chapter-item expanded "><a href="quick_start/static_layout.html"><strong aria-hidden="true">1.3.</strong> Static Layout</a></li><li class="chapter-item expanded "><a href="quick_start/dynamic_layout.html"><strong aria-hidden="true">1.4.</strong> Dynamic Layout</a></li><li class="chapter-item expanded "><a href="quick_start/adding_style.html"><strong aria-hidden="true">1.5.</strong> Adding Style</a></li><li class="chapter-item expanded "><a href="quick_start/responding_to_actions.html"><strong aria-hidden="true">1.6.</strong> Responding to Actions</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Yarrow GUI Framework</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<blockquote>
<p>This book is currently a WIP</p>
</blockquote>
<p>Welcome to the official book for the Yarrow GUI framework!</p>
<p>Yarrow is a modern retained-mode GUI library in Rust with extreme performance and control, geared towards audio software. It was built to power the upcoming <a href="https://github.com/MeadowlarkDAW/Meadowlark">Meadowlark</a> DAW.</p>
<p>The repository for the project is located at <a href="https://github.com/MeadowlarkDAW/Yarrow">https://github.com/MeadowlarkDAW/Yarrow</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>The Yarrow framework is built using the Rust programming language. Currently, to use Yarrow, you must install the Rust compiler by following the instructions over at <a href="https://www.rust-lang.org/learn/get-started">https://www.rust-lang.org/learn/get-started</a>.</p>
<h2 id="running-the-examples"><a class="header" href="#running-the-examples">Running the Examples</a></h2>
<p>The <a href="https://github.com/MeadowlarkDAW/Yarrow">Yarrow repository</a> on github contains some example applications. To run these examples, first clone the repository to a local directory. Then inside a terminal, navigate to the root directory and run the following command:</p>
<p><code>cargo run --example &lt;name_of_example&gt;</code></p>
<p>Where <code>&lt;name_of_example&gt;</code> should be replaced with the example name (i.e. <code>cargo run --example gallery</code>)</p>
<h2 id="join-the-community"><a class="header" href="#join-the-community">Join the Community</a></h2>
<p>If you have any questions about Yarrow or you wish to contribute, come join us on the <a href="https://discord.gg/2W3Xvc8wy4">Meadowlark Discord Server</a> under the #yarrow channel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-guide"><a class="header" href="#quick-start-guide">Quick Start Guide</a></h1>
<blockquote>
<p>This guide is currently a WIP</p>
</blockquote>
<p>This chapter will walk you through the basics of Yarrow by creating a simple application.</p>
<p>This book is not meant as an introduction to the Rust programming language. If you are new to Rust, it is highly recommended to first read through the <a href="https://doc.rust-lang.org/book/">official Rust book</a>. You can find even more Rust learning resources at <a href="https://www.rust-lang.org/learn">https://www.rust-lang.org/learn</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up"><a class="header" href="#setting-up">Setting Up</a></h1>
<p>First, create a new Rust project with the following command:</p>
<p><code>cargo new --bin hello_yarrow</code></p>
<h2 id="adding-yarrow-as-a-dependency"><a class="header" href="#adding-yarrow-as-a-dependency">Adding Yarrow as a dependency</a></h2>
<p>In the newly created directory, open the <code>Cargo.toml</code> file and add the following under <code>[dependencies]</code>:</p>
<pre><code class="language-toml">[package]
name = "hello_yarrow"
version = "0.1.0"
edition = "2021"

[dependencies]
yarrow = { git = "https://github.com/MeadowlarkDAW/Yarrow.git", branch = "main" }
</code></pre>
<blockquote>
<p>Yarrow does not have a recent version published on crates.io yet, so you will need to use the git version for now.</p>
</blockquote>
<h2 id="enabling-additional-optimizations"><a class="header" href="#enabling-additional-optimizations">Enabling Additional Optimizations</a></h2>
<p>Some aspects of Yarrow such as text shaping can run very slow when compiled in debug mode without any optimizations. It is recommended to add the follow to your <code>Cargo.toml</code> file to get acceptable performance when running in debug mode:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<h2 id="initializing-the-application"><a class="header" href="#initializing-the-application">Initializing the Application</a></h2>
<p>In <code>main.rs</code>, replace the default contents with the following:</p>
<pre><pre class="playground"><code class="language-rust">use yarrow::prelude::*; // 1

pub fn main() {
    let (action_sender, action_receiver) = yarrow::action_channel(); // 2

    yarrow::run_blocking( // 3
        MyApp::new(action_sender.clone(), action_receiver),
        action_sender,
    )
    .unwrap();
}

struct MyApp { // 4
    _action_sender: ActionSender&lt;()&gt;,
    _action_receiver: ActionReceiver&lt;()&gt;,
}

impl MyApp {
    fn new(
        action_sender: ActionSender&lt;()&gt;,
        action_receiver: ActionReceiver&lt;()&gt;
    ) -&gt; Self {
        Self {
            _action_sender: action_sender,
            _action_receiver: action_receiver,
        }
    }
}

impl Application for MyApp { // 5
    type Action = (); // 6
}</code></pre></pre>
<p>Here is a breakdown of what is happening:</p>
<ol>
<li>Import a bunch of types from Yarrow. Yarrow provides a <code>prelude</code> module that re-exports most of everything you need for simplicity.</li>
<li>Create an action channel. We will cover what actions are and how they work later in this chapter. For now just know this is essentially an <a href="https://doc.rust-lang.org/std/sync/mpsc/">mpsc</a> channel from Rust's standard library.</li>
<li>Run our application. For standalone applications you will want to use <code>run_blocking</code>, but Yarrow contains other methods for running in different kinds of contexts (like an audio plugin).</li>
<li>Our application struct. This is where we will store everything related to our application. Note that we are holding onto the action channel objects, as we will use them later. (Your application struct must hold on to at least the <code>ActionReceiver</code> object or it might panic).</li>
<li>The <code>yarrow::Application</code> trait. We must implement this for our application object.</li>
<li>Define the type to use as our applications's action message. For now we have no actions, so we will set it to the empty type <code>()</code>.</li>
</ol>
<h2 id="running-the-application"><a class="header" href="#running-the-application">Running the Application</a></h2>
<p>Now run the application using the command <code>cargo run</code>. Once it finishes compiling you should see an empty black window.</p>
<p><img src="quick_start/../img/initial_window.png" alt="Initial Window" /></p>
<blockquote>
<p>The first compile may take quite a while as it is compiling an entire GUI library from scratch. Subsequent compiles should be much faster.</p>
</blockquote>
<p>Yarrow is still experimental software. If you run into any issues while compiling or running this code, please create an issue in the <a href="https://github.com/MeadowlarkDAW/Yarrow/issues">github repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-element"><a class="header" href="#your-first-element">Your First Element</a></h1>
<p>Let's start by adding a <code>Label</code> element with the text "Hello World!".</p>
<h2 id="a-place-to-store-our-elements"><a class="header" href="#a-place-to-store-our-elements">A Place to Store our Elements</a></h2>
<p>First we will need to create a struct to hold our elements for the main window. Add the following struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MainWindowElements {
    hello_label: Label,
}
<span class="boring">}</span></code></pre></pre>
<p>Why can't we just add <code>hello_label</code> directly to our <code>MyApp</code> struct? The reason is that a Yarrow application is designed to work even when the main window isn't open. This is a useful concept for audio plugins. Plus, this allows the same behavior to work for both the main window and any child windows in our application (Yarrow has first-class multi-window support!)</p>
<p>Now add the following field to the <code>MyApp</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyApp {
    main_window_elements: Option&lt;MainWindowElements&gt;, // new

    _action_sender: ActionSender&lt;()&gt;,
    _action_receiver: ActionReceiver&lt;()&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>And in <code>MyApp::new()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(
    action_sender: ActionSender&lt;()&gt;,
    action_receiver: ActionReceiver&lt;()&gt;
) -&gt; Self {
    Self {
        main_window_elements: None, // new

        _action_sender: action_sender,
        _action_receiver: action_receiver,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-build-function"><a class="header" href="#the-build-function">The Build Function</a></h2>
<p>Now we must define a function to "build" our elements when the window opens. To do this, add the following method to <code>MainWindowElements</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MainWindowElements {
    pub fn build(cx: &amp;mut WindowContext&lt;'_, ()&gt;) -&gt; Self {
        
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now we must call that build function when the main window opens. To do this, implement the <code>on_window_event</code> method on the Application trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Application for MyApp {
    type Action = ();

    // new
    fn on_window_event(
        &amp;mut self,
        event: AppWindowEvent,
        window_id: WindowID,
        cx: &amp;mut AppContext&lt;()&gt;,
    ) {
        match event {
            AppWindowEvent::WindowOpened =&gt; {
                if window_id == MAIN_WINDOW { // 1
                    let mut main_window_cx =
                        cx.window_context(MAIN_WINDOW).unwrap(); // 2

                    self.main_window_elements =
                        Some(MainWindowElements::build(&amp;mut main_window_cx)); // 3
                }
            }
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>Check the ID of the window to see if it is the main window. This will always be the case for our simple app, but this won't be the case if we add child windows in the future.</li>
<li>Get the context for the main window. This context is what we add elements to.</li>
<li>Build the main window elements and store it in our application struct.</li>
</ol>
<h2 id="building-the-label-element"><a class="header" href="#building-the-label-element">Building the Label Element</a></h2>
<p>Now we finally get to build the label! Inside <code>MainWindowElements::build</code>, add the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn build(cx: &amp;mut WindowContext&lt;'_, ()&gt;) -&gt; Self {
    // new
    Self {
        hello_label: Label::builder() // 1
            .text("Hello World!") // 2
            .build(cx), // 3
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>All included elements in Yarrow use the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a>.</li>
<li>Elements can include any custom property in their builders. In this case we use the <code>text</code> property to set the text of the label.</li>
<li>Finally, finish building the element by adding it to the window context.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-layout"><a class="header" href="#static-layout">Static Layout</a></h1>
<p>If you run the application now, you will see that the window is still blank. This is because in order for elements to become active and be rendered, they must have a defined "bounding rectangle".</p>
<p>You can add a bounding rectangle by using the <code>bounding_rect</code> property on the label builder like this. Now the label is visible when the app is run.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>hello_label: Label::builder()
    .text("Hello World!")
    .bounding_rect(rect(0.0, 0.0, 100.0, 30.0)) // new
    .build(cx),
<span class="boring">}</span></code></pre></pre>
<p><img src="quick_start/../img/static_layout_1.png" alt="Static Layout 1" /></p>
<p>If we want to place the label in a different position, all we need to do is change the (x, y) values in the bounding rect:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.bounding_rect(rect(100.0, 40.0, 100.0, 30.0))
<span class="boring">}</span></code></pre></pre>
<p><img src="quick_start/../img/static_layout_2.png" alt="Static Layout 2" /></p>
<p>Also note that if we make the (width, height) values in the bounding rect small enough, the text will be clipped:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.bounding_rect(rect(100.0, 40.0, 30.0, 10.0))
<span class="boring">}</span></code></pre></pre>
<p>[TODO: screenshot, and actually make the text clip because I must have broke that lol]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-layout"><a class="header" href="#dynamic-layout">Dynamic Layout</a></h1>
<p>Setting the bounding rectangle inside of the element builder works great and all for static content, but what if we wanted the layout to dynamically change due to a change in the application state (or the window being resized)? And for that matter, what if we wanted to layout other elements based on the size of the text in the label element?</p>
<p>To achieve this, we will define a "layout function" for our main window. Remove the <code>.bounding_rect</code> property from the Label builder and then add the following method to <code>MainWindowElements</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MainWindowElements {
    // ...

    // new
    pub fn layout(&amp;mut self, cx: &amp;mut WindowContext&lt;'_, ()&gt;) {
        let label_size = self.hello_label.desired_size(cx.res); // 1

        // Center the label inside the window
        let window_rect = Rect::from_size(cx.logical_size()); // 2
        let label_rect = centered_rect(window_rect.center(), label_size); // 3

        self.hello_label.el.set_rect(label_rect); // 4
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>The <code>desired_size</code> method can be used to get the desired size of any element with text content (or some other dynamically sized content). This value is automatically cached by the element, so it is relatively inexpensive to call it over and over again if need be.</li>
<li>Get the size of the window from the window context. Also convert that size into a rectangle for ease of use later (Yarrow uses <a href="https://crates.io/crates/euclid">euclid</a> for geometric types).</li>
<li>Create a rectangle that is centered inside of <code>window_rect</code> using the provided helper method.</li>
<li>Set the bounding rectangle via the label element's handle. Note the <code>.el</code> in the middle. Every element handle has a generic <code>el</code> field with generic methods that are shared by all element types. For example, the generic <code>el</code> field also has a <code>rect()</code> method that can retrieve the current bounding rectangle of the element, which is very useful when the layout of some elements depend on the layout of other elements.</li>
</ol>
<blockquote>
<p>Note that the same effect can be achieved by using the <code>layout_aligned</code> method on the <code>Label</code> handle:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let window_rect = Rect::from_size(cx.logical_size());
self.hello_label.layout_aligned(window_rect.center(), Align2::CENTER, cx.res);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>No we must call the layout function after the main window is built and whenever the window resizes. To do this, add the following to the <code>on_window_event</code> trait method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_window_event(
    &amp;mut self,
    event: AppWindowEvent,
    window_id: WindowID,
    cx: &amp;mut AppContext&lt;Self::Action&gt;,
) {
    match event {
        AppWindowEvent::WindowOpened =&gt; {
            if window_id == MAIN_WINDOW {
                let mut main_window_cx =
                    cx.window_context(MAIN_WINDOW).unwrap();

                self.main_window_elements =
                    Some(MainWindowElements::build(&amp;mut main_window_cx));

                // new
                self.main_window_elements
                    .as_mut()
                    .unwrap()
                    .layout(&amp;mut main_window_cx);
            }
        }
        // new
        AppWindowEvent::WindowResized =&gt; {
            if window_id == MAIN_WINDOW {
                let mut main_window_cx =
                    cx.window_context(MAIN_WINDOW).unwrap();

                self.main_window_elements
                    .as_mut()
                    .unwrap()
                    .layout(&amp;mut main_window_cx);
            }
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now the label stays in the center of the window!</p>
<p><img src="quick_start/../img/dynamic_layout_1.png" alt="Centered Label" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-style"><a class="header" href="#adding-style">Adding Style</a></h1>
<p>Now let's make the label more visually interesting.</p>
<p>To be more representative of a real-world application, let us define a struct to hold all of the style related information about our application:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct MyStyle {}
<span class="boring">}</span></code></pre></pre>
<p>This struct has no fields yet, but we will add some later.</p>
<p>For now, let us define a method which loads the styles for the elements we want:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyStyle {
    pub fn load(&amp;self, res: &amp;mut ResourceCtx) { // 1
        res.style_system.add( // 2
            "",   // 3
            true, // 4
            LabelStyle { // 5
                back_quad: QuadStyle {
                    bg: Background::Solid(RGBA8::new(100, 30, 80, 255)),
                    border: BorderStyle {
                        color: RGBA8::new(200, 60, 160, 255),
                        width: 2.0,
                        radius: 10.0.into(),
                    },
                    ..Default::default()
                },
                text_padding: Padding::new(10.0, 10.0, 10.0, 10.0),
                ..Default::default() // 6
            },
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>Pass in the <code>ResourceCtx</code>, which is a context for the globally shared resources in a Yarrow application.</li>
<li>Add a style to the context's <code>StyleSystem</code>.</li>
<li>The "class name". Only elements that have this class name will have this style applied to them. The blank name of <code>""</code> means to set it as the default style for all elements of this type which don't have a defined class name.</li>
<li>Whether or not this style is a dark theme variant (true) or a light theme variant (false). This allows for easy switching between light and dark variants later.</li>
<li>Every element type defines its own custom style struct with custom properties.</li>
<li>The <code>..Default::default()</code> syntax is handy for not defining properties you do not use.</li>
</ol>
<p>Now store our new style struct in <code>MyApp</code> and load it when the application starts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyApp {
    // ...

    // new
    style: MyStyle,
}

impl MyApp {
    fn new(action_sender: ActionSender&lt;()&gt;, action_receiver: ActionReceiver&lt;()&gt;) -&gt; Self {
        Self {
            // ...
            
            // new
            style: MyStyle::default(),
        }
    }
}

impl Application for MyApp {
    type Action = ();

    fn on_window_event(
        &amp;mut self,
        event: AppWindowEvent,
        window_id: WindowID,
        cx: &amp;mut AppContext&lt;Self::Action&gt;,
    ) {
        match event {
            AppWindowEvent::WindowOpened =&gt; {
                if window_id == MAIN_WINDOW {
                    // new
                    self.style.load(&amp;mut cx.res);

                    let mut main_window_cx =
                        cx.window_context(MAIN_WINDOW).unwrap();

                    // ...
                }
            }
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now our label is looking fancy!</p>
<p><img src="quick_start/../img/adding_style_1.png" alt="Fancy Label" /></p>
<h1 id="loading-a-theme"><a class="header" href="#loading-a-theme">Loading a Theme</a></h1>
<p>By default all elements have a style which is very bare-bones (and most of the time colors are set to transparent). If you want a quicker starting place, you can load one of Yarrow's built in themes. A "theme" is simply a function with a few tweakable parameters that adds a bunch of styles.</p>
<p>At the time of this writing, Yarrow has only one built-in theme called "Yarrow dark". To use it, simply add this inside of <code>MyStyle::load()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>yarrow::theme::yarrow_dark::load(None, None, res);
<span class="boring">}</span></code></pre></pre>
<p>After loading a theme, it's probably a good idea to use a class for our custom fancy label so it doesn't conflict with the default one in the theme:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In MyStyle::load

res.style_system.add(
    "fancy_label", // changed
    // ...
);

// In MainWindowElements::build

hello_label: Label::builder()
    .text("Hello World!")
    .class("fancy_label") // new
    .build(cx),

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="responding-to-actions"><a class="header" href="#responding-to-actions">Responding to Actions</a></h1>
<p>[TODO]</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
